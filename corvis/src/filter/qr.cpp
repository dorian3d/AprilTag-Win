//  qr.cpp
//
//  Created by Brian on 12/9/14.
//  Copyright (c) 2014 RealityCap. All rights reserved.
//
//  Adapted from /cpp/cli/src/main.cpp

#include "qr.h"
#include "filter.h"

#include <zxing/Result.h>
#include <zxing/ReaderException.h>
#include <zxing/common/IllegalArgumentException.h>
#include <zxing/BinaryBitmap.h>
#include <zxing/DecodeHints.h>
#include <zxing/qrcode/QRCodeReader.h>
#include <zxing/multi/qrcode/QRCodeMultiReader.h>
#include <zxing/common/HybridFastBinarizer.h>

using namespace std;
using namespace zxing;
using namespace zxing::multi;
using namespace zxing::qrcode;

vector<Ref<Result> > decode(Ref<BinaryBitmap> image, DecodeHints hints) {
    Ref<Reader> reader(new QRCodeReader);
    return vector<Ref<Result> >(1, reader->decode(image, hints));
}

vector<Ref<Result> > decode_multi(Ref<BinaryBitmap> image, DecodeHints hints) {
    QRCodeMultiReader reader;
    return reader.decodeMultiple(image, hints);
}

vector<Ref<Result> > detect_qr(const char * image, int width, int height) {
    vector<Ref<Result> > results;
    string cell_result;
    int res = -1;
    bool search_multi = false;

    try {
        Ref<Binarizer> binarizer;
        Ref<LuminanceSource> source(new DummyLuminanceSource(width, height));
        binarizer = new HybridFastBinarizer(image, width, height, source);
        DecodeHints hints(DecodeHints::DEFAULT_HINT);
        hints.setTryHarder(false);
        Ref<BinaryBitmap> binary(new BinaryBitmap(binarizer));
        if (search_multi) {
            results = decode_multi(binary, hints);
        } else {
            results = decode(binary, hints);
        }
        res = 0;
    } catch (const ReaderException& e) {
        cell_result = "zxing::ReaderException: " + string(e.what());
        res = -2;
    } catch (const zxing::IllegalArgumentException& e) {
        cell_result = "zxing::IllegalArgumentException: " + string(e.what());
        res = -3;
    } catch (const zxing::Exception& e) {
        cell_result = "zxing::Exception: " + string(e.what());
        res = -4;
    } catch (const std::exception& e) {
        cell_result = "std::exception: " + string(e.what());
        res = -5;
    }

    /*
    for (size_t i = 0; i < results.size(); i++) {
        cout << "  Format: " << BarcodeFormat::barcodeFormatNames[results[i]->getBarcodeFormat()];
        for (int j = 0; j < results[i]->getResultPoints()->size(); j++) {
            cout << "  Point[" << j <<  "]: "
            << results[i]->getResultPoints()[j]->getX() << " "
            << results[i]->getResultPoints()[j]->getY() << endl;
        }
        cout << results[i]->getText()->getText() << endl;
    }
    */

    return results;
}

bool qr_detect_one(const uint8_t * image, int width, int height, struct qr_detection & d)
{
    vector<Ref<Result> > results = detect_qr((const char *)image, width, height);
    if(results.size() > 0) {
        ArrayRef<Ref<zxing::ResultPoint> > res = results[0]->getResultPoints();
        if(res->size() == 4) {
            d.lower_left.x = res[0]->getX();
            d.lower_left.y = res[0]->getY();
            d.upper_left.x = res[1]->getX();
            d.upper_left.y = res[1]->getY();
            d.upper_right.x = res[2]->getX();
            d.upper_right.y = res[2]->getY();
            d.lower_right.x = res[3]->getX();
            d.lower_right.y = res[3]->getY();
            d.modules = results[0]->getVersion()*4 + 17; // size of qr code is defined by the version
            Ref<zxing::String> data = results[0]->getText();
            strncpy(d.data, data->getText().c_str(), 1024);
            return true;
        }
        else {
            fprintf(stderr, "Warning: qr detected, but with %d points\n", res->size());
        }
    }

    return false;
}

#include "homography.h"

/*
 * Computes a homography between calibrated image points and a fake image.
 * The fake image is generated by a virtual camera located at the world
 * coord (0, 0, -1), aligned with the world axis, looking at a qr code on the
 * plane z=0.
 *
 * This homography is decomposed into a rotation and translation, which is
 * the rotation and translation to bring a point from the virtual
 * camera frame to the camera frame which generated the calibrated points.
 *
 * The translation is then composed with a translation from the origin of the
 * fake camera to its image plane, so the resulting R&T represent the
 * transformation required to take the camera which took the calibrated
 * points to the center of the qr code.
 *
 * qr_size is the width in meters of the qr code in world coordinates.
 *
 * R and T provided by qr code transform: X_cam = Rq * X_new_world + Tq
 * Saved transformation: X_old_world = Rs * X_cam + Ts
 *
 * So result is X_old_world = Rs * (Rq * X_new_world + Tq) + Ts
 * We want zaxis new = zaxis old, so we will find an Rd that aligns them, and set Rq = Rq * Rd
 */

bool qr_code_homography(const struct filter *f, struct qr_detection detection, float qr_size_m, quaternion &Q, v4 &T)
{
    feature_t image_corners[4];
    feature_t calibrated[4];

    image_corners[0].x = detection.upper_left.x;
    image_corners[0].y = detection.upper_left.y;
    image_corners[1].x = detection.lower_left.x;
    image_corners[1].y = detection.lower_left.y;
    image_corners[2].x = detection.lower_right.x;
    image_corners[2].y = detection.lower_right.y;
    image_corners[3].x = detection.upper_right.x;
    image_corners[3].y = detection.upper_right.y;
    for(int c = 0; c < 4; c++) {
        calibrated[c] = f->s.calibrate_feature(image_corners[c]);
    }

    m4 Rq; v4 Tq;
    if(homography_align_to_qr(calibrated, qr_size_m, detection.modules, Rq, Tq)) {
        Q = to_quaternion(Rq);
        T = Tq;
        return true;
    }
    return false;
}

bool qr_code_origin(const struct filter *f, struct qr_detection detection, float qr_size_m, bool use_gravity, quaternion &Q, v4 &T)
{
    quaternion Qq;
    v4 Tq;
    if(qr_code_homography(f, detection, qr_size_m, Qq, Tq)) {
        quaternion Qw = to_quaternion(f->s.W.v);
        quaternion Qc = to_quaternion(f->s.Wc.v);

        quaternion Qsq = quaternion_product(Qw, quaternion_product(Qc, Qq));

        v4 Tsq = f->s.T.v + quaternion_rotate(Qw, f->s.Tc.v + quaternion_rotate(Qc, Tq));

        quaternion Qsqd = Qsq;
        if(use_gravity) {
            v4 z_old(0., 0., 1., 0.);
            v4 z_new = quaternion_rotate(conjugate(Qsq), z_old);
            quaternion Qd = rotation_between_two_vectors_normalized(z_old, z_new);
            Qsqd = quaternion_product(Qsq, Qd);
        }

        // inverse of transformation specified by Qsqd, Tsq
        Q = conjugate(Qsqd);
        T = quaternion_rotate(Q, -Tsq);
        return true;
    }
    else
        return false;
}

void qr_benchmark::process_frame(const struct filter * f, const uint8_t * image, int width, int height)
{
    qr_detection d;
    quaternion Q;
    v4 T;
    if(qr_detect_one(image, width, height, d)) {
        if(qr_code_homography(f, d, size_m, Q, T)) {
            if(!origin_valid) {
                origin_valid = true;

                origin_qr = transformation(Q, T);
                origin_state = compose(transformation(f->s.W.v, f->s.T.v), transformation(f->s.Wc.v, f->s.Tc.v));
            }
            else {
                transformation now_qr = transformation(Q, T);
                transformation now_state = compose(transformation(f->s.W.v, f->s.T.v), transformation(f->s.Wc.v, f->s.Tc.v));

                transformation now_state_est = compose(origin_state, compose(origin_qr, invert(now_qr)));

                quaternion dQ = quaternion_product(now_state_est.Q, conjugate(now_state.Q));
                v4 dT = now_state_est.T - quaternion_rotate(dQ, now_state.T);
                fprintf(stderr, "dR="); to_rotation_matrix(dQ).print(); fprintf(stderr, ";\n");
                fprintf(stderr, "dT="); dT.print(); fprintf(stderr, ";\n");
                fprintf(stderr, "norm(dT)=%f;\n", norm(dT));
            }
        }
    }
}
