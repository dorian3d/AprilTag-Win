diff --git a/common/components/BLIS/leon/frame/3/gemm/bli_gemm_ker_var2.c b/common/components/BLIS/leon/frame/3/gemm/bli_gemm_ker_var2.c
index 0295518..8efd0d1 100644
--- mdk_release_17.04.5_general_purpose/mdk/common/components/BLIS/leon/frame/3/gemm/bli_gemm_ker_var2.c
+++ mdk_release_17.04.5_general_purpose_patched/mdk/common/components/BLIS/leon/frame/3/gemm/bli_gemm_ker_var2.c
@@ -35,6 +35,7 @@
 #include "blis.h"
 #include "Helpers.h"
 #include "mv_types.h"
+#include "OsDrvSvu.h"
 
 #define FUNCPTR_T gemm_fp
 
@@ -130,6 +131,7 @@ void bli_gemm_ker_var2( obj_t*  a,
 	   buf_c, rs_c, cs_c );
 }
 
+static osDrvSvuHandler_t handler[MAX_SHAVES];
 #ifdef SHAVE_BLIS
 void bli_sgemm_ker_var2(
         dim_t   m,
@@ -244,13 +246,38 @@ void bli_sgemm_ker_var2(
     kernelInfo.cs_c    = cs_c;
     kernelInfo.rstep_a = rstep_a;
     kernelInfo.cstep_b = cstep_b;
-
+    s32 sc;
+    u32 running;
     for (shaveIdx = 0; shaveIdx < numberShaves; shaveIdx++)
     {
         shaveNr = listShaves[shaveIdx];
-        swcResetShave(shaveNr);
-        swcSetAbsoluteDefaultStack(shaveNr);
-        swcStartShaveCC(shaveNr, entryPointsSGEMM[shaveNr], "iii", (u32)&kernelInfo, startIter, endIter);
+        sc = OsDrvSvuOpenShave(&handler[shaveNr], shaveNr, OS_MYR_PROTECTION_SEM);
+        if (sc == OS_MYR_DRV_SUCCESS)
+        {
+            sc = OsDrvSvuResetShave(&handler[shaveNr]);
+            if (sc)
+            {
+                printf("OsDrvSvuResetShave %d\n", sc);
+                return;
+            }
+            sc = OsDrvSvuSetAbsoluteDefaultStack(&handler[shaveNr]);
+            if (sc)
+            {
+                printf("OsDrvSvuSetAbsoluteDefaultStack %d\n", sc);
+                return;
+            }
+            sc = OsDrvSvuStartShaveCC(&handler[shaveNr], (u32) entryPointsSGEMM[shaveNr], "iii", (u32)&kernelInfo, startIter, endIter);
+            if (sc)
+            {
+                printf("OsDrvSvuStartShaveCC %d\n", sc);
+                return;
+            }
+        }
+        else
+        {
+            printf("OsDrvSvuOpenShave %d, Number %d\n", sc, shaveNr);
+            return;
+        }
         startIter = endIter;
         /* Check last SHAVE */
         if(shaveIdx == numberShaves - modIter - 1)
@@ -259,7 +286,26 @@ void bli_sgemm_ker_var2(
         }
         endIter += stepIter;
     }
-    swcWaitShaves(numberShaves, listShaves);
+    for (shaveIdx = 0; shaveIdx < numberShaves; shaveIdx++)
+    {
+        shaveNr = listShaves[shaveIdx];
+        if (shaveNr < TOTAL_NUM_SHAVES)
+        {
+            sc = OsDrvSvuWaitShaves(1, &handler[shaveNr], OS_DRV_SVU_WAIT_FOREVER, &running);
+            if (sc)
+            {
+                printf("OsDrvSvuWaitShaves %d\n", sc);
+                return;
+            }
+            sc = OsDrvSvuCloseShave(&handler[shaveNr]);
+            if (sc != OS_MYR_DRV_SUCCESS)
+            {
+                printf("OsDrvSvuCloseShave %d, Index %d\n", sc, shaveNr);
+                return;
+            }
+        } else
+            return;
+    }
 #ifdef MYRIAD2
     DrvShaveL2CachePartitionFlushAndInvalidate(0);
 #endif
