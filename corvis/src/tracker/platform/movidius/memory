#pragma once

#include_next <memory>

// note: this implementation does not disable this overload for array
// types
namespace std {
#ifndef make_unique
    template<typename T>
    typename enable_if<is_array<T>::value,unique_ptr<T>>::type make_unique(size_t size)
    {
        return unique_ptr<T>(new typename remove_extent<T>::type[size]);
    }

    template<typename T, typename... Args>
    typename enable_if<!is_array<T>::value,unique_ptr<T>>::type make_unique(Args&&... args)
    {
        return unique_ptr<T>(new T(forward<Args>(args)...));
    }
#endif
}
