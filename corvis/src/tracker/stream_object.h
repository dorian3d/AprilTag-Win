#pragma once

#include <memory>
#include <mutex>
#include <condition_variable>
#include <deque>
#include <vector>
#include <iomanip>

#include "bstream.h"
#include "packet.h"

struct packet_header_t;
class replay_output;

typedef std::unique_ptr<packet_t, decltype(&free)> rc_packet_t;

class host_stream {
public:
    /// make stream object ready
    virtual bool init_stream() = 0;
    ///start streaming out sensor data and streaming in tracking results.
    virtual bool start_stream() = 0;
    /// post a packet to the stream object that will be read back later.
    /// if the packet is mixed with others from a different stream, the ordering w.r.t other packets is not defined.
    virtual void put_host_packet(rc_packet_t &&post_packet) = 0;
    /// get number of bytes of sensor data dispatched in the stream.
    virtual uint64_t get_bytes_dispatched() = 0;
    /// get number of sensor packets dispatched in the stream.
    virtual uint64_t get_packets_dispatched() = 0;
    /// callback function on host side upon receipt of replay_output.
    std::function<void(const replay_output *, const rc_Data *)> host_data_callback{ nullptr };
    /// callback function on streaming progress, meaningful only for streaming from a recording file.
    std::function<void(float)> progress_callback{ nullptr };
    std::function<void(rc_Stage)> host_stage_callback{ nullptr };
    /// wait until a packet of ANY give type by the parameter is generated by the device program.
    void wait_device_packet(const std::vector<uint32_t> pkt_types) {
        std::unique_lock<std::mutex> lk(wait_device_mtx);
        device_response.wait(lk, [&] {
            bool arrived = false;
            for (auto type : pkt_types)
                if (arrived_type == type) {
                    arrived = true;
                    break;
                }
            return arrived;
        });
    }
    /// tracking statistics.
    std::string tracking_stat;
    virtual ~host_stream() {};
protected:
    std::mutex wait_device_mtx;
    std::condition_variable device_response;
    uint32_t arrived_type{ 0 }; ///type of control packet sent by device program.
};


class device_stream {
public:
    /// make stream object ready for streaming.
    virtual bool init_device() = 0;
    /// allocates a new packet and assigns header of the next packet in the stream.
    /// waits until there is a packet.
    virtual bool read_header(packet_header_t *header, bool control_type = false) = 0;
    /// acquire and own pointer to the current packet. This function must be called after read_header.
    /// user is required to FREE the pointer after usage.
    virtual  rc_packet_t get_host_packet() = 0;
    /// post a packet to the stream object that will be queued and read back later.
    /// after packet is read back and processed, its allocation will be freed by user. 
    virtual void put_device_packet(const rc_packet_t &post_packet) = 0;
    rc_LoadCallback map_load_callback{ nullptr };
    rc_SaveCallback save_callback{ nullptr };
    rc_DataCallback pose_callback{ nullptr };
    rc_MessageCallback message_callback{ nullptr };
    rc_StatusCallback status_callback{ nullptr };
    rc_StageCallback stage_callback{ nullptr };
    void *map_load_handle{ nullptr }, *save_handle{ nullptr }, *pose_handle{ nullptr }, *stage_handle{ nullptr };
    virtual ~device_stream() {};
};

static inline void pose_data_callback(void * handle, rc_Tracker * tracker, const rc_Data * data) {
    replay_output *output = (replay_output *)handle;
    output->confidence = (int8_t)rc_getConfidence(tracker);
    output->path_length = rc_getPathLength(tracker);
    output->sensor_time_us = data->time_us;
    output->data_path = data->path;
    output->sensor_type = data->type;
    // update for both fast and slow path to match internal changes in tracker
    output->rc_setPose(rc_DATA_PATH_FAST, rc_getPose(tracker, nullptr, nullptr, rc_DATA_PATH_FAST));
    output->rc_setPose(rc_DATA_PATH_SLOW, rc_getPose(tracker, nullptr, nullptr, rc_DATA_PATH_SLOW));
    if (output->get_output_type() == replay_output::output_mode::POSE_FEATURE) {
        if (data->type == rc_SENSOR_TYPE_IMAGE || data->type == rc_SENSOR_TYPE_STEREO) {
            rc_Feature *cur_feat = nullptr;
            uint32_t num_features = rc_getFeatures(tracker, data->id, &cur_feat);
            output->rc_setFeatures(cur_feat, num_features);
        }
    }
    output->tracker = tracker;
    if (output->on_track_output) output->on_track_output(output, data);
}

/// packet type used for replay, must not exceed max(uint8_t).
typedef enum replay_packet_type {
    packet_command_init = 180,
    packet_command_reset,
    packet_command_end,
    packet_command_toggle_pause,
    packet_command_next_pause,
    packet_command_step,
    packet_ack, //acknowledgment
    packet_transfer_end,
    packet_enable_realtime,
    packet_enable_qvga,
    packet_enable_qres, //w. downscaling ratio by 0
    packet_enable_async,
    packet_enable_no_depth,
    packet_enable_fast_path,
    packet_enable_zero_biases,
    packet_enable_mesg_level,
    packet_enable_mapping,
    packet_enable_relocalization,
    packet_enable_features_output,
    packet_enable_odometry,
    packet_enable_stage_callback,
    packet_timing_stat,
    packet_load_calibration,
    packet_save_calibration,
    packet_load_map,
    packet_save_map,
    packet_save_data, //packet used by device to send for saving
    packet_save_end, //packet used by device to send for saving
    packet_set_stage,
} replay_packet_type;

static inline rc_packet_t packet_control_alloc(uint8_t control_type, const char *load, size_t load_size) {
    packet_control_t *new_packet = (packet_control_t *)malloc(sizeof(packet_header_t) + load_size);
    new_packet->header.type = packet_control;
    new_packet->header.control_type = control_type;
    new_packet->header.time = 0; //not used yet
    new_packet->header.bytes = (uint32_t)(sizeof(packet_header_t) + load_size);
    if (load) memcpy(new_packet->data, load, load_size);
    return rc_packet_t((packet_t *)new_packet, free);
}

static inline rc_packet_t packet_command_alloc(uint8_t control_type) {
    return packet_control_alloc(control_type, NULL, 0);
}

static inline void set_control_packet(packet_control_t *packet, uint8_t type, const char *load,
    size_t load_size) {
    packet->header.type = packet_control;
    packet->header.control_type = type;
    packet->header.time = 0;
    packet->header.bytes = (uint32_t)(sizeof(packet_header_t) + load_size);
    if (load && load_size > 0)
        memcpy(packet->data, load, load_size);
}

static inline uint8_t get_packet_type(const rc_packet_t &packet) {
    if (packet->header.type == packet_control)
        return (uint8_t)((packet_control_t *)packet.get())->header.control_type;
    else return (uint8_t)packet->header.type;
}

